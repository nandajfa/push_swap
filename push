ARG=$(shuf -i 0-100) && ./push_swap $ARG | wc -l

MAX INT 2147483647
MIN INT -2147483648

A Análise da complexidade procura estimar a velocidade do algoritmo. Prever o tempo que o algoritmo vai consumir. 
Verificar qual é o custo de usar um dado algoritmo para resolver um problema específico. Porém, neste aspecto, encontram-se duas dificuldades:

O tempo gasto depende dos dados de entrada.
O tempo também depende da capacidade de hardware do computador utilizado.
____________________________________________
Os métodos simples são adequados para pequenos vetores, são programas pequenos e fáceis de entender. 
Possuem complexidade C(n) = O(n²), ou seja, requerem O(n²) comparações. Exemplos: Insertion Sort, Selection Sort, Bubble Sort, Comb Sort.
Nos algoritmos de ordenação as medidas de complexidade relevantes são:

Número de comparações C(n) entre chaves.
Número de movimentações M(n) dos registros dos vetores.
Onde n é o número de registros.



Tres numeros

1 3 2 rra
2 1 3 sa
1 2 3 

2 3 1 rra
1 2 3

2 1 3 sa
1 2 3

3 1 2  ra
1 2 3

3 2 1 ra
2 1 3 sa
1 2 3
________________________________________________
FIVE NB

5 4 3 2 1

index = 4 (rra)
1 5 4 3 2 (push_b)
A  5 4 3 2    B 1

FOUR
5 4 3 2
index = 3 (rra)
2 5 4 3 (push_b)
A 5 4 3        B 2 1
____________________________________________
5 4 1 3 2

index = 2 (ra)
4 1 3 2 5 
index = 1 (ra)
1 3 2 5 4 (push_b)
A 3 2 5 4    B 1

3 2 5 4
index = 1 (ra)
2 5 4 3 (push_b)
A 5 4 3    B  2 1





